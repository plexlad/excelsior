/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AsciiMathPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// node_modules/.pnpm/ts-dedent@2.2.0/node_modules/ts-dedent/esm/index.js
function dedent(templ) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var strings = Array.from(typeof templ === "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str) {
    var matches = str.match(/\n([\t ]+|(?!\s).)/g);
    if (matches) {
      return arr.concat(matches.map(function(match) {
        var _a, _b;
        return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }));
    }
    return arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str) {
      return str.replace(pattern_1, "\n");
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  values.forEach(function(value, i2) {
    var endentations = string.match(/(?:^|\n)( *)$/);
    var endentation = endentations ? endentations[1] : "";
    var indentedValue = value;
    if (typeof value === "string" && value.includes("\n")) {
      indentedValue = String(value).split("\n").map(function(str, i3) {
        return i3 === 0 ? str : "" + endentation + str;
      }).join("\n");
    }
    string += indentedValue + strings[i2 + 1];
  });
  return string;
}
var esm_default = dedent;

// node_modules/.pnpm/asciimath-parser@0.6.3/node_modules/asciimath-parser/dist/index.js
var f = ((T) => (T.NumberLiteral = "NumberLiteral", T.StringLiteral = "StringLiteral", T.Text = "Text", T.Const = "Const", T.OperatorOA = "OperatorA", T.OperatorOAB = "OperatorOAB", T.OperatorAOB = "OperatorAOB", T.OperatorMinus = "OperatorMinus", T.OperatorAO = "OperatorAO", T.OperatorO2 = "OperatorOptionalTwoParams", T.OperatorSup = "OperatorSup", T.OperatorPartial = "OperatorPartial", T.LParen = "LParen", T.RParen = "RParen", T.Paren = "Paren", T.Align = "Align", T.Split = "Split", T.None = "None", T))(f || {});
var C = /* @__PURE__ */ new Map([["alpha", { type: "Const", tex: "\\alpha" }], ["beta", { type: "Const", tex: "\\beta" }], ["gamma", { type: "Const", tex: "\\gamma" }], ["Gamma", { type: "Const", tex: "\\Gamma" }], ["delta", { type: "Const", tex: "\\delta" }], ["Delta", { type: "Const", tex: "\\Delta" }], ["epsi", { type: "Const", tex: "\\varepsilon" }], ["epsilon", { type: "Const", tex: "\\epsilon" }], ["varepsilon", { type: "Const", tex: "\\varepsilon" }], ["zeta", { type: "Const", tex: "\\zeta" }], ["eta", { type: "Const", tex: "\\eta" }], ["theta", { type: "Const", tex: "\\theta" }], ["Theta", { type: "Const", tex: "\\Theta" }], ["vartheta", { type: "Const", tex: "\\vartheta" }], ["iota", { type: "Const", tex: "\\iota" }], ["kappa", { type: "Const", tex: "\\kappa" }], ["lambda", { type: "Const", tex: "\\lambda" }], ["Lambda", { type: "Const", tex: "\\Lambda" }], ["mu", { type: "Const", tex: "\\mu" }], ["nu", { type: "Const", tex: "\\nu" }], ["xi", { type: "Const", tex: "\\xi" }], ["Xi", { type: "Const", tex: "\\Xi" }], ["pi", { type: "Const", tex: "\\pi" }], ["Pi", { type: "Const", tex: "\\Pi" }], ["rho", { type: "Const", tex: "\\rho" }], ["sigma", { type: "Const", tex: "\\sigma" }], ["Sigma", { type: "Const", tex: "\\Sigma" }], ["tau", { type: "Const", tex: "\\tau" }], ["upsilon", { type: "Const", tex: "\\upsilon" }], ["phi", { type: "Const", tex: "\\phi" }], ["varphi", { type: "Const", tex: "\\varphi" }], ["varPhi", { type: "Const", tex: "\\varPhi" }], ["Phi", { type: "Const", tex: "\\Phi" }], ["chi", { type: "Const", tex: "\\chi" }], ["psi", { type: "Const", tex: "\\psi" }], ["Psi", { type: "Const", tex: "\\Psi" }], ["omega", { type: "Const", tex: "\\omega" }], ["Omega", { type: "Const", tex: "\\Omega" }], ["***", { type: "Const", tex: "\\star" }], ["star", { type: "Const", tex: "\\star" }], ["**", { type: "Const", tex: "\\ast" }], ["ast", { type: "Const", tex: "\\ast" }], ["*", { type: "Const", tex: "\\cdot" }], ["cdot", { type: "Const", tex: "\\cdot" }], ["//", { type: "Const", tex: "{/}" }], ["\\\\", { type: "Const", tex: "\\backslash" }], ["setminus", { type: "Const", tex: "\\setminus" }], ["xx", { type: "Const", tex: "\\times" }], ["|><", { type: "Const", tex: "\\ltimes" }], ["><|", { type: "Const", tex: "\\rtimes" }], ["|><|", { type: "Const", tex: "\\bowtie" }], ["-:", { type: "Const", tex: "\\div" }], ["@", { type: "Const", tex: "\\circ" }], ["o+", { type: "Const", tex: "\\oplus" }], ["ox", { type: "Const", tex: "\\otimes" }], ["o.", { type: "Const", tex: "\\odot" }], ["sum", { type: "Const", tex: "\\sum" }], ["prod", { type: "Const", tex: "\\prod" }], ["^^", { type: "Const", tex: "\\wedge" }], ["^^^", { type: "Const", tex: "\\bigwedge" }], ["vv", { type: "Const", tex: "\\vee" }], ["vvv", { type: "Const", tex: "\\bigvee" }], ["nn", { type: "Const", tex: "\\cap" }], ["nnn", { type: "Const", tex: "\\bigcap" }], ["uu", { type: "Const", tex: "\\cup" }], ["uuu", { type: "Const", tex: "\\bigcup" }], ["!=", { type: "Const", tex: "\\ne" }], ["lt", { type: "Const", tex: "<" }], ["<=", { type: "Const", tex: "\\leqslant" }], ["le", { type: "Const", tex: "\\le" }], ["gt", { type: "Const", tex: ">" }], [">=", { type: "Const", tex: "\\geqslant" }], ["ge", { type: "Const", tex: "\\ge" }], ["-<", { type: "Const", tex: "\\prec" }], [">-", { type: "Const", tex: "\\succ" }], ["-<=", { type: "Const", tex: "\\preceq" }], [">-=", { type: "Const", tex: "\\succeq" }], ["in", { type: "Const", tex: "\\in" }], ["!in", { type: "Const", tex: "\\notin" }], ["sub", { type: "Const", tex: "\\subset" }], ["sup", { type: "Const", tex: "\\supset" }], ["sube", { type: "Const", tex: "\\subseteq" }], ["supe", { type: "Const", tex: "\\supseteq" }], ["-=", { type: "Const", tex: "\\equiv" }], ["~=", { type: "Const", tex: "\\cong" }], ["~", { type: "Const", tex: "\\sim" }], ["~~", { type: "Const", tex: "\\approx" }], ["\\#", { type: "Const", tex: "\\#" }], ["\\&", { type: "Const", tex: "\\&" }], ["\\@", { type: "Const", tex: "@" }], ["\\%", { type: "Const", tex: "\\%" }], ["%", { type: "Const", tex: "\\%" }], ["\\_", { type: "Const", tex: "\\_" }], ["\\^", { type: "Const", tex: "\\^" }], ["\\$", { type: "Const", tex: "\\$" }], ["\\ ", { type: "Const", tex: "\\ " }], ["\\,", { type: "Const", tex: "\\," }], ["\\;", { type: "Const", tex: "\\;" }], ["\\:", { type: "Const", tex: "\\:" }], ["\\!", { type: "Const", tex: "\\!" }], ["enspace", { type: "Const", tex: "\\enspace" }], ["hspace", { type: "OperatorA", tex: "\\hspace{$1}", eatNext: true }], ["prop", { type: "Const", tex: "\\propto" }], ["comp", { type: "Const", tex: "\\complement" }], ["complement", { type: "Const", tex: "\\complement" }], ["if", { type: "Text", tex: "if\\quad" }], ["otherwise", { type: "Text", tex: "otherwise\\quad" }], ["and", { type: "Text", tex: " and " }], ["or", { type: "Text", tex: " or " }], ["not", { type: "Const", tex: "\\neg" }], ["=>", { type: "Const", tex: "\\implies" }], ["~>", { type: "Const", tex: "\\rightsquigarrow" }], ["-/->", { type: "Const", tex: "\\nrightarrow" }], ["<-/-", { type: "Const", tex: "\\nleftarrow" }], ["<-/->", { type: "Const", tex: "\\nleftrightarrow" }], ["<=>", { type: "Const", tex: "\\iff" }], ["iff", { type: "Const", tex: "\\iff" }], ["AA", { type: "Const", tex: "\\forall" }], ["EE", { type: "Const", tex: "\\exists" }], ["_|_", { type: "Const", tex: "\\bot" }], ["TT", { type: "Const", tex: "\\top" }], ["|--", { type: "Const", tex: "\\vdash" }], ["|==", { type: "Const", tex: "\\models" }], ["int", { type: "Const", tex: "\\int" }], ["oint", { type: "Const", tex: "\\oint" }], ["del", { type: "Const", tex: "\\partial" }], ["grad", { type: "Const", tex: "\\nabla" }], ["+-", { type: "Const", tex: "\\pm" }], ["-+", { type: "Const", tex: "\\mp" }], ["O/", { type: "Const", tex: "\\varnothing" }], ["oo", { type: "Const", tex: "\\infty" }], ["aleph", { type: "Const", tex: "\\aleph" }], ["...", { type: "Const", tex: "\\ldots" }], [":.", { type: "Const", tex: "\\therefore" }], [":'", { type: "Const", tex: "\\because" }], ["/_", { type: "Const", tex: "\\angle" }], ["/_\\", { type: "Const", tex: "\\triangle" }], ["quad", { type: "Const", tex: "\\quad" }], ["qquad", { type: "Const", tex: "\\qquad" }], ["cdots", { type: "Const", tex: "\\cdots" }], ["vdots", { type: "Const", tex: "\\vdots" }], ["ddots", { type: "Const", tex: "\\ddots" }], ["diamond", { type: "Const", tex: "\\diamond" }], ["Lap", { type: "Const", tex: "\\mathscr{L}" }], ["square", { type: "Const", tex: "\\square" }], ["|__", { type: "LParen", tex: "\\lfloor" }], ["__|", { type: "RParen", tex: "\\rfloor" }], ["|~", { type: "LParen", tex: "\\lceil" }], ["~|", { type: "RParen", tex: "\\rceil" }], ["CC", { type: "Const", tex: "\\mathbb{C}" }], ["NN", { type: "Const", tex: "\\mathbb{N}" }], ["QQ", { type: "Const", tex: "\\mathbb{Q}" }], ["RR", { type: "Const", tex: "\\mathbb{R}" }], ["ZZ", { type: "Const", tex: "\\mathbb{Z}" }], ["'", { type: "Const", tex: "^{\\prime}" }], ["''", { type: "Const", tex: "^{\\prime\\prime}" }], ["'''", { type: "Const", tex: "^{\\prime\\prime\\prime}" }], ["lim", { type: "Const", tex: "\\lim" }], ["sin", { type: "Const", tex: "\\sin" }], ["cos", { type: "Const", tex: "\\cos" }], ["tan", { type: "Const", tex: "\\tan" }], ["sinh", { type: "Const", tex: "\\sinh" }], ["cosh", { type: "Const", tex: "\\cosh" }], ["tanh", { type: "Const", tex: "\\tanh" }], ["cot", { type: "Const", tex: "\\cot" }], ["sec", { type: "Const", tex: "\\sec" }], ["csc", { type: "Const", tex: "\\csc" }], ["arcsin", { type: "Const", tex: "\\arcsin" }], ["arccos", { type: "Const", tex: "\\arccos" }], ["arctan", { type: "Const", tex: "\\arctan" }], ["coth", { type: "Const", tex: "\\coth" }], ["sech", { type: "Const", tex: "\\operatorname{sech}" }], ["csch", { type: "Const", tex: "\\operatorname{csch}" }], ["exp", { type: "Const", tex: "\\exp" }], ["log", { type: "Const", tex: "\\log" }], ["ln", { type: "Const", tex: "\\ln" }], ["det", { type: "Const", tex: "\\det" }], ["dim", { type: "Const", tex: "\\dim" }], ["gcd", { type: "Const", tex: "\\gcd" }], ["lcm", { type: "Const", tex: "\\operatorname{lcm}" }], ["min", { type: "Const", tex: "\\min" }], ["max", { type: "Const", tex: "\\max" }], ["Sup", { type: "Const", tex: "\\sup" }], ["inf", { type: "Const", tex: "\\inf" }], ["mod", { type: "Const", tex: "\\operatorname{mod}" }], ["sgn", { type: "Const", tex: "\\operatorname{sgn}" }], ["abs", { type: "OperatorA", tex: "\\left|$1\\right|" }], ["norm", { type: "OperatorA", tex: "\\left\\|$1\\right\\|" }], ["floor", { type: "OperatorA", tex: "\\left\\lfloor$1\\right\\rfloor" }], ["ceil", { type: "OperatorA", tex: "\\left\\lceil$1\\right\\rceil" }], ["uarr", { type: "Const", tex: "\\uparrow" }], ["uparrow", { type: "Const", tex: "\\uparrow" }], ["darr", { type: "Const", tex: "\\downarrow" }], ["downarrow", { type: "Const", tex: "\\downarrow" }], ["rarr", { type: "Const", tex: "\\rightarrow" }], ["rightarrow", { type: "Const", tex: "\\rightarrow" }], ["to", { type: "Const", tex: "\\to" }], ["->", { type: "Const", tex: "\\to" }], ["<-", { type: "Const", tex: "\\gets" }], [">->", { type: "Const", tex: "\\rightarrowtail" }], ["->>", { type: "Const", tex: "\\twoheadrightarrow" }], [">->>", { type: "Const", tex: "\u2916" }], ["|->", { type: "Const", tex: "\\mapsto" }], ["larr", { type: "Const", tex: "\\leftarrow" }], ["leftarrow", { type: "Const", tex: "\\leftarrow" }], ["harr", { type: "Const", tex: "\\leftrightarrow" }], ["rArr", { type: "Const", tex: "\\Rightarrow" }], ["lArr", { type: "Const", tex: "\\Leftarrow" }], ["hArr", { type: "Const", tex: "\\Leftrightarrow" }], ["curvArrLt", { type: "Const", tex: "\\curvearrowleft" }], ["curvArrRt", { type: "Const", tex: "\\curvearrowright" }], ["circArrLt", { type: "Const", tex: "\\circlearrowleft" }], ["circArrRt", { type: "Const", tex: "\\circlearrowright" }], ["sqrt", { type: "OperatorA", tex: "\\sqrt{ $1 }" }], ["root", { type: "OperatorOAB", tex: "\\sqrt[ $1 ]{ $2 }" }], ["frac", { type: "OperatorOAB", tex: "\\frac{ $1 }{ $2 }" }], ["/", { type: "OperatorAOB", tex: "\\frac{ $1 }{ $2 }" }], ["choose", { type: "OperatorAOB", tex: "{ $1 \\choose $2 }" }], ["_", { type: "OperatorSup", tex: "_{ $1 }" }], ["^", { type: "OperatorSup", tex: "^{ $1 }" }], ["stackrel", { type: "OperatorOAB", tex: "\\stackrel{ $1 }{ $2 }" }], ["overset", { type: "OperatorOAB", tex: "\\overset{ $1 }{ $2 }" }], ["underset", { type: "OperatorOAB", tex: "\\underset{ $1 }{ $2 }" }], ["hat", { type: "OperatorA", tex: "\\hat{ $1 }" }], ["\\`", { type: "OperatorA", tex: "\\`{ $1 }" }], ["widehat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["Hat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["widetilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["ol", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["overline", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["arc", { type: "OperatorA", tex: "\\stackrel{\\frown}{ $1 }" }], ["bar", { type: "OperatorA", tex: "\\bar{ $1 }" }], ["vec", { type: "OperatorA", tex: "\\vec{ $1 }" }], ["Vec", { type: "OperatorA", tex: "\\overrightarrow{ $1 }" }], ["tilde", { type: "OperatorA", tex: "\\tilde{ $1 }" }], ["Tilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["dot", { type: "OperatorA", tex: "\\dot{ $1 }" }], ["ddot", { type: "OperatorA", tex: "\\ddot{ $1 }" }], ["ul", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underline", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underbrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["ubrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["overbrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["obrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["color", { type: "OperatorOAB", tex: "{ \\color{$1} $2 }", eatNext: true }], ["phantom", { type: "OperatorA", tex: "\\phantom{$1}" }], ["text", { type: "OperatorA", tex: "\\text{$1}", eatNext: true }], ["tex", { type: "OperatorA", tex: "$1", eatNext: true }], ["mbox", { type: "OperatorA", tex: "\\mbox{$1}" }], ["op", { type: "OperatorA", tex: "\\operatorname{ $1 }", eatNext: true }], ["cancel", { type: "OperatorA", tex: "\\cancel{ $1 }" }], ["bb", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["mathbf", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["sf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["mathsf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["bbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["mathbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["cc", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["mathcal", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["tt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["mathtt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["fr", { type: "OperatorA", tex: "\\mathfrak{ $1 }" }], ["bm", { type: "OperatorA", tex: "\\boldsymbol{ $1 }" }], ["rm", { type: "OperatorA", tex: "\\mathrm{ $1 }" }], ["scr", { type: "OperatorA", tex: "\\mathscr{ $1 }" }], ["limits", { type: "OperatorA", tex: "\\mathop{ $1 }\\limits" }], ["iint", { type: "Const", tex: "\\iint" }], ["iiint", { type: "Const", tex: "\\iiint" }], ["oiint", { type: "Const", tex: "\u222F" }], ["oiiint", { type: "Const", tex: "\u2230" }], ["laplace", { type: "Const", tex: "\\Delta" }], ["==", { type: "OperatorOptionalTwoParams", tex: "\\xlongequal[ $2 ]{ $1 }" }], ["-->", { type: "OperatorOptionalTwoParams", tex: "\\xrightarrow[ $2 ]{ $1 }" }], ["||", { type: "Paren", tex: "\\Vert" }], ["!||", { type: "Const", tex: "\u2226" }], ["S=", { type: "Const", tex: "\u224C" }], ["S~", { type: "Const", tex: "\u223D" }], ["!-=", { type: "Const", tex: "\\not\\equiv" }], ["!|", { type: "Const", tex: "\u2224" }], ["!", { type: "OperatorAO", tex: "{$1 !}" }], ["!!", { type: "OperatorAO", tex: "{$1 !!}" }], ["!sube", { type: "Const", tex: "\\not\\subseteq" }], ["!supe", { type: "Const", tex: "\\not\\supseteq" }], ["subne", { type: "Const", tex: "\\subsetneqq" }], ["supne", { type: "Const", tex: "\\supsetneqq" }], ["lhd", { type: "Const", tex: "\\lhd" }], ["rhd", { type: "Const", tex: "\\rhd" }], ["normal", { type: "Const", tex: "\\unlhd" }], ["rnormal", { type: "Const", tex: "\\unrhd" }], ["hline", { type: "Const", tex: "\\hline" }], ["--", { type: "Const", tex: "\\hline" }], ["(", { type: "LParen", tex: "(" }], [")", { type: "RParen", tex: ")" }], ["[", { type: "LParen", tex: "[" }], ["]", { type: "RParen", tex: "]" }], ["{", { type: "LParen", tex: "\\lbrace" }], ["}", { type: "RParen", tex: "\\rbrace" }], ["(:", { type: "LParen", tex: "\\langle" }], [":)", { type: "RParen", tex: "\\rangle" }], ["{:", { type: "LParen", tex: "." }], [":}", { type: "RParen", tex: "." }], ["|", { type: "Paren", tex: "|" }], ["&", { type: "Align", tex: "&" }], ["&&", { type: "Align", tex: "&&" }], [",", { type: "Split", tex: "," }], [";", { type: "Split", tex: ";" }], ["-", { type: "OperatorMinus", tex: "{-$1 }" }], ["+", { type: "OperatorMinus", tex: "{+$1 }" }], ["part", { type: "OperatorPartial", tex: "\\partial" }], ["pp", { type: "OperatorPartial", tex: "\\partial" }], ["dd", { type: "OperatorPartial", tex: "\\mathrm{d}" }], ["tiny", { type: "OperatorA", tex: "{\\tiny $1 }" }], ["small", { type: "OperatorA", tex: "{\\small $1 }" }], ["large", { type: "OperatorA", tex: "{\\large $1 }" }], ["huge", { type: "OperatorA", tex: "{\\huge $1 }" }]]);
function V() {
  return { type: "Root", body: [] };
}
function i(o) {
  if (typeof o > "u")
    return { type: "Const", value: "", tex: "" };
  if (typeof o == "string")
    return { type: "Const", value: o, tex: o };
  let e;
  return o.type === "Text" ? e = o.tex.replace(/^(\\quad)?(.+?)(\\quad)?$/, (t, n, p, s) => `${n || ""}\\text{${p}}${s || ""}`) : e = o.tex, { type: "Const", value: o.value, tex: e };
}
function d(o) {
  let e = [];
  return o && (Array.isArray(o) ? e = o : e.push(o)), { type: "Flat", body: e };
}
function v() {
  return { type: "Matrix", params: [], lparen: ".", rparen: ".", alignment: "c", dividerIndices: [] };
}
function m() {
  return { type: "ParamOne", tex: "", params: d() };
}
function c() {
  return { type: "ParamTwo", tex: "", params: [d(), d()] };
}
function A(o, e) {
  return { type: "Const", value: o.value, tex: `\\${e ? "left" : "right"}${o.tex}` };
}
function z(o, e) {
  let { closingIndex: t, semiIndex: n } = B(e, o);
  return t === -1 ? M(o, e) : n === -1 || n > t ? L(o, e, t) : F(o, e, t);
}
function w(o, e) {
  if (e + 1 >= o.length)
    return;
  let t = o[e], n = o[e + 1];
  t.type === "Const" && t.tex === "\\hline" && n.type === "Paren" && ([o[e], o[e + 1]] = [n, t]);
}
function F(o, e, t) {
  let n = o[e], p = v(), s = /* @__PURE__ */ new Set();
  p.lparen = `\\left${n.tex}`, e++;
  let a = [], r = null;
  for (w(o, e), n = o[e]; e < t; ) {
    if (n = o[e], n.value === ",") {
      r ? (a.push(r), r = null) : a.push(i()), ++e;
      continue;
    } else if (n.value === ";" || n.tex === "\\\\") {
      r && (a.push(r), r = null), p.params.push(a), a = [], e++, w(o, e);
      continue;
    } else if (n.type === "Paren") {
      r && (a.push(r), r = null), s.add(a.length), e++;
      continue;
    }
    for (r = d(); e < t && n.type !== "Split" && n.type !== "Paren" && n.type !== "Align"; ) {
      let y = l(o, e);
      e = y.current, r.body.push(y.node), n = o[e];
    }
  }
  return r && (a.push(r), r = null), a.length > 0 && (p.params.push(a), a = []), p.dividerIndices = Array.from(s).sort((y, u) => y - u), n = o[e], e < o.length ? (e++, p.rparen = `\\right${n.tex}`, n.value === ":}" && p.lparen.endsWith("lbrace") && (p.alignment = "l")) : p.rparen = "\\right.", { node: p, current: e };
}
var g = class extends Error {
};
function L(o, e, t) {
  let n = o[e], p = d();
  if (p.body.push(A(n, true)), e = O(e + 1, t, o, p), e >= o.length)
    throw new g(`Read index out of range, index: ${e}`);
  return n = o[e], e++, p.body.push(A(n, false)), p.body[0].value === "{:" && p.body[p.body.length - 1].value === ":}" && (p.body[0].tex = "{", p.body[p.body.length - 1].tex = "}"), { node: p, current: e };
}
function M(o, e) {
  let t = o[e], n = d();
  return n.body.push({ type: "Const", value: t.value, tex: `\\left${t.tex}` }), e = O(e + 1, o.length, o, n), n.body.push({ type: "Const", value: t.value, tex: "\\right." }), { node: n, current: e };
}
function B(o, e) {
  let t = -1, n = -1, p = [];
  for (let s = o + 1; s < e.length; s++) {
    if (e[s].type === "LParen") {
      p.push("");
      continue;
    }
    if (p.length === 0) {
      if (e[s].value === ";" ? t === -1 && (t = s) : e[s].type === "RParen" && n === -1 && (n = s), t !== -1 && n !== -1)
        break;
    } else
      e[s].type === "RParen" && p.pop();
  }
  return { closingIndex: n, semiIndex: t };
}
function q(o, e, t, n) {
  let p = -1, s = -1, a = [];
  for (let r = e; r < t; r++) {
    if (o[r].type === "LParen") {
      a.push("");
      continue;
    }
    if (a.length > 0 && o[r].type === "RParen") {
      a.pop();
      continue;
    }
    if (!(a.length > 0) && (o[r].type === "RParen" || (o[r].value === ";" ? p === -1 && (p = r) : o[r].value === n && s === -1 && (s = r), p !== -1 && s !== -1)))
      break;
  }
  return { semiIndex: p, barIndex: s };
}
function E(o, e) {
  let t = o[e], { semiIndex: n, barIndex: p } = q(o, e + 1, o.length, t.value);
  if (p === -1)
    return I(e, t);
  if (n === -1 || n > p) {
    let y = d();
    return e++, y.body.push(i(`\\left${t.tex}`)), e = O(e, p, o, y), y.body.push(i(`\\right${t.tex}`)), e = p + 1, { current: e, node: y };
  }
  let s = v();
  s.lparen = `\\left${t.tex}`, s.rparen = `\\right${t.tex}`, t = o[++e];
  let a = [], r = null;
  for (; e < p; ) {
    if (t.type === "Split") {
      switch (t.value) {
        case ",": {
          r ? (a.push(r), r = null) : a.push(i());
          break;
        }
        case ";": {
          r && (a.push(r), r = null), s.params.push(a), a = [];
          break;
        }
      }
      t = o[++e];
      continue;
    }
    for (r = d(), t = o[e]; e < p && t.type !== "Split"; ) {
      let y = l(o, e);
      e = y.current, r.body.push(y.node), t = o[e];
    }
  }
  return r && (a.push(r), r = null), a.length > 0 && (s.params.push(a), a = []), e = p + 1, { node: s, current: e };
}
function O(o, e, t, n) {
  for (; o < e; ) {
    let p = l(t, o);
    o = p.current, n.body.push(p.node);
  }
  return o;
}
function I(o, e) {
  return { current: o + 1, node: { type: "Const", value: e.value, tex: e.tex === "|" ? "\\mid" : e.tex } };
}
function k(o) {
  let e = o.body[0], t = o.body[o.body.length - 1];
  return e.type === "Const" && t.type === "Const" && e.value === "(" && t.value === ")" && (o.body.pop(), o.body.shift()), o;
}
function W(o, e, t) {
  let n = o[e], p = i(), s = "", a = "", r = "";
  if (n.value === "^" || n.value === "_") {
    s = n.value === "^" ? "_" : "^", a = n.value, e++;
    let x = l(o, e, false);
    x.node.type === "Flat" && (x.node = k(x.node)), p = x.node, e = x.current;
  }
  let y = i();
  if (e < o.length && (n = o[e], n.value === s)) {
    r = n.value, e++;
    let x = l(o, e, false);
    x.node.type === "Flat" && (x.node = k(x.node)), y = x.node, e = x.current;
  }
  let u = c();
  return u.tex = t.tex, u.params[0] = (() => a === "^" ? p : r === "^" ? y : i())(), u.params[1] = (() => a === "_" ? p : r === "_" ? y : i())(), { node: u, current: e };
}
function D(o, e, t, n) {
  let p;
  o.type === "Flat" ? p = o : (p = d(), p.body.push(o));
  let s = m();
  s.tex = e.tex;
  let a = l(t, n, false);
  if (n = a.current, a.node.type === "Flat")
    a.node = k(a.node);
  else if (a.node.type === "Matrix") {
    let r = a.node;
    r.lparen.endsWith("(") && r.rparen.endsWith(")") && (r.lparen = "", r.rparen = "");
  }
  return s.params = a.node, p.body.push(s), o = p, { node: o, current: n };
}
function K(o, e) {
  let t = m();
  return t.params = o, t.tex = e.tex, o = t, o;
}
function j(o, e, t, n) {
  let p = c();
  o.type === "Flat" && (o = k(o)), p.tex = e.tex, p.params[0] = o;
  let s = l(t, n);
  return n = s.current, s.node.type === "Flat" && (s.node = k(s.node)), p.params[1] = s.node, o = p, { node: o, current: n };
}
function $(o, e, t) {
  let n = m(), p = o[e];
  n.tex = p.tex, e++;
  let s = l(o, e, t);
  return e = s.current, s.node.type === "Flat" && (s.node = k(s.node)), n.params = s.node, { node: n, current: e };
}
function G(o, e) {
  let t = o[e];
  if (e > 0) {
    let a = o[e - 1];
    if (a.type !== "OperatorSup" && a.type !== "OperatorA" && a.type !== "OperatorOAB" && a.type !== "OperatorAOB")
      return { node: i(t.value), current: e + 1 };
  } else
    return { node: i(t.value), current: e + 1 };
  if (e++, e >= o.length)
    return { node: i(t.value), current: e };
  if (o[e].type === "RParen")
    return { node: i(t.value), current: e };
  let p = l(o, e, true);
  e = p.current;
  let s = m();
  return s.tex = t.tex, s.params = p.node, { node: s, current: e };
}
function Q(o, e, t) {
  let n = d();
  return n.body.push(i(o)), e && n.body.push(e), n.body.push(t), n;
}
function U(o, e) {
  return d(o.body.map((t) => [i(e), t]).flat());
}
function Z(o, e) {
  let t = c(), n = o[e];
  t.tex = "\\frac{ $1 }{ $2 }";
  let p = n.tex, s = null;
  if (e++, e >= o.length)
    return { node: t, current: e };
  if (n = o[e], n.type === "OperatorSup") {
    let y = $(o, e, false);
    e = y.current, s = y.node;
  }
  let a = l(o, e, true);
  if (e = a.current, a.node.type === "Flat" && (a.node = k(a.node)), t.params[0] = Q(p, s, a.node), e >= o.length)
    return { node: t, current: e };
  let r = l(o, e);
  return e = r.current, r.node.type === "Flat" ? (r.node = k(r.node), r.node = U(r.node, p)) : (r.node = d(r.node), r.node.body.unshift(i(p)), s && r.node.body.push(s)), t.params[1] = r.node, { node: t, current: e };
}
function l(o, e, t = true) {
  if (e >= o.length)
    return { node: i(), current: e };
  let n = o[e], p;
  switch (n.type) {
    case "Const":
    case "Text":
    case "NumberLiteral":
    case "StringLiteral": {
      e++, p = i(n);
      break;
    }
    case "LParen": {
      ({ node: p, current: e } = z(o, e));
      break;
    }
    case "Paren": {
      ({ node: p, current: e } = E(o, e));
      break;
    }
    case "OperatorSup":
    case "OperatorA": {
      ({ node: p, current: e } = $(o, e, false));
      break;
    }
    case "OperatorMinus": {
      ({ node: p, current: e } = G(o, e));
      break;
    }
    case "OperatorOAB": {
      p = c(), p.tex = n.tex, e++;
      let s = l(o, e);
      e = s.current, s.node.type === "Flat" && (s.node = k(s.node)), p.params[0] = s.node;
      let a = l(o, e);
      e = a.current, a.node.type === "Flat" && (a.node = k(a.node)), p.params[1] = a.node;
      break;
    }
    case "OperatorOptionalTwoParams": {
      if (e++, e >= o.length) {
        p = i(`${n.tex.replace(/[\{\[] \$\d+ [\}\]]/g, "")}{}`);
        break;
      }
      ({ node: p, current: e } = W(o, e, n));
      break;
    }
    case "OperatorPartial": {
      ({ node: p, current: e } = Z(o, e));
      break;
    }
    case "Split":
    case "Align": {
      e++, p = i(n);
      break;
    }
    case "RParen": {
      e++, p = i(n);
      break;
    }
    default:
      throw new Error(`Unmatched token in walk ${n.value}`);
  }
  if (e < o.length && t) {
    let s = true;
    for (; s && e < o.length; ) {
      let a = o[e];
      switch (a.type) {
        case "OperatorAOB": {
          ({ node: p, current: e } = j(p, a, o, e + 1));
          break;
        }
        case "OperatorAO": {
          p = K(p, a), e++;
          break;
        }
        case "OperatorSup": {
          ({ node: p, current: e } = D(p, a, o, e + 1));
          break;
        }
        default:
          s = false;
      }
    }
  }
  return { node: p, current: e };
}
function P(o) {
  let e = V(), t = 0;
  for (; t < o.length; ) {
    let n = l(o, t);
    t = n.current, e.body.push(n.node);
  }
  return e;
}
function H(o) {
  let e = o.dividerIndices, t = "\\begin{array}", n = o.alignment;
  if (e.length) {
    let p = e[e.length - 1];
    for (let a = e.length - 1; a >= 1; a--)
      e[a] -= e[a - 1];
    t += "{";
    for (let a = 0; a < e.length; a++)
      t += `${n.repeat(e[a])}|`;
    let s = Math.max(...o.params.map((a) => a.length));
    t += `${n.repeat(s - p)}}`;
  } else {
    let p = Math.max(...o.params.map((s) => s.length));
    t += `{${n.repeat(p)}}`;
  }
  return [t, "\\end{array}"];
}
function h(o) {
  switch (o.type) {
    case "Const":
      return o.tex;
    case "Root": {
      let e = o.body.map(h).join(" ");
      return o.body.find((t) => t.type === "Const" && (t.value === "&" || t.tex === "\\\\")) && (e = `\\begin{aligned}${e}\\end{aligned}`), e;
    }
    case "Flat":
      return o.body.map(h).join(" ");
    case "Matrix": {
      let [e, t] = H(o);
      return [o.lparen, e, o.params.map((n) => n.map(h).join(" & ")).join(" \\\\ "), t, o.rparen].join(" ");
    }
    case "ParamOne":
      return o.tex.replace("$1", h(o.params));
    case "ParamTwo":
      return o.tex.replace("$1", h(o.params[0])).replace("$2", h(o.params[1]));
  }
}
var R = /[0-9]/;
var X = /\S/;
var Y = (o) => {
  let { value: e = "", current: t } = o;
  return { value: e, isKeyWord: false, current: t, tex: e, type: "Const" };
};
var N = class {
  constructor(e) {
    __publicField(this, "_root");
    __publicField(this, "_char_to_index", /* @__PURE__ */ new Map());
    __publicField(this, "_n");
    if (e.length === 0)
      throw new Error("Cannot create Trie since the length of nodes is 0");
    e.forEach((n) => {
      if (n.length !== 1)
        throw new Error(`Value \`${n}\` is invalid, the length of char must be 1`);
    });
    let t = Array.from(new Set(e));
    this._n = t.length, this._root = new b(this._n), t.forEach((n, p) => {
      this._char_to_index.set(n, p);
    });
  }
  c2i(e) {
    return this._char_to_index.get(e);
  }
  insert(e) {
    if (e.length === 0)
      return;
    let t = this._root;
    [...e].forEach((n, p) => {
      let s = this.c2i(n);
      if (typeof s > "u")
        throw new Error(`key \`${n}\` not in key set`);
      t._nextNode[s] === null && (t._nextNode[s] = new b(this._n)), t = t._nextNode[s], p === e.length - 1 && (t._end = true);
    });
  }
  search(e) {
    if (!this._root._nextNode.find((p) => p !== null) || e.length === 0)
      return false;
    let t = this._root, n = 0;
    for (; n < e.length; n++) {
      let p = e[n], s = this.c2i(p);
      if (typeof s > "u")
        throw new Error(`key \`${p}\` not in key set`);
      if (t._nextNode[s] === null)
        return false;
      t = t._nextNode[s];
    }
    return n === e.length;
  }
  tryParsing(e, t = 0) {
    let n = "", p = this._root, s = false, a = t;
    for (; a < e.length; a++) {
      let y = e[a], u = this.c2i(y);
      if (typeof u > "u" || p._nextNode[u] === null)
        break;
      n += y, p = p._nextNode[u], s = p._end;
    }
    let r = (() => s ? C.get(n) : { tex: n, type: "StringLiteral" })();
    return { value: n, isKeyWord: s, current: a, ...r };
  }
  tryParsingNumber(e, t) {
    let n = e[t], p = "";
    for (; R.test(n) && t < e.length; )
      p += n, n = e[++t];
    for (n === "." && (p += n, n = e[++t]); R.test(n) && t < e.length; )
      p += n, n = e[++t];
    return { value: p, isKeyWord: false, current: t, tex: p, type: "NumberLiteral" };
  }
  tryParsingString(e, t) {
    let n = e[t], p = "";
    for (; X.test(n) && t < e.length; ) {
      let s = this.c2i(n);
      if (typeof s < "u" && this._root._nextNode[s] !== null)
        break;
      p += n, n = e[++t];
    }
    return { value: p, isKeyWord: false, current: t, tex: p, type: "StringLiteral" };
  }
  tryParsingNewLines(e, t) {
    let n = e[t], p = "";
    for (; /\n/.test(n) && t < e.length; )
      p += n, n = e[++t];
    return p.length >= 2 ? { value: p, isKeyWord: true, current: t, tex: "\\\\", type: "Align" } : { value: "", isKeyWord: false, current: t, tex: "", type: "None" };
  }
  getPlainTextInDoubleQuote(e, t) {
    let n = "", p = e[t];
    if (p === '"') {
      for (p = e[++t]; p !== '"' && t < e.length; )
        n += p, p = e[++t];
      if (p === '"')
        return t++, { current: t, value: n };
    }
    return { value: n, current: t };
  }
  tryParsingText(e, t) {
    let { value: n, current: p } = this.getPlainTextInDoubleQuote(e, t);
    return { value: n, isKeyWord: false, current: p, tex: n, type: "Text" };
  }
  skipSpaces(e, t) {
    for (; t < e.length; ) {
      let n = e[t];
      if (!/\s/.test(n))
        break;
      t++;
    }
    return t;
  }
  eatNext(e, t) {
    t = this.skipSpaces(e, t);
    let n = Y({ current: t });
    if (t >= e.length)
      return n;
    let p = e[t], s = "";
    switch (p) {
      case '"': {
        for (p = e[++t]; t < e.length && p !== '"'; )
          s += p, p = e[++t];
        t++;
        break;
      }
      case "(": {
        for (p = e[++t]; t < e.length && p !== ")"; )
          s += p, p = e[++t];
        t++;
        break;
      }
      default: {
        for (; t < e.length && /\S/.test(p); )
          p = e[t++], s += p;
        break;
      }
    }
    return n.tex = n.value = s, n.current = t, n;
  }
  tryParsingAll(e) {
    let t = 0, n = [], p = 0, s = [...e];
    for (; t < s.length; ) {
      {
        let r = this.tryParsingNewLines(s, t);
        if (t = r.current, r.value !== "") {
          n.push(r);
          continue;
        }
      }
      if (/\s/.test(s[t])) {
        t++;
        continue;
      }
      let a = this.tryParsing(s, t);
      if (t = a.current, a.value !== "") {
        if (n.push(a), a.eatNext) {
          let r = this.eatNext(s, t);
          t = r.current, n.push(r);
        }
        continue;
      }
      {
        let r = this.tryParsingNumber(s, t);
        if (t = r.current, r.value !== "") {
          n.push(r);
          continue;
        }
      }
      {
        let r = this.tryParsingText(s, t);
        if (t = r.current, r.value !== "") {
          n.push(r);
          continue;
        }
      }
      {
        let r = this.tryParsingString(s, t);
        if (t = r.current, r.value !== "") {
          n.push(r);
          continue;
        }
      }
      if (p++, p > s.length * 2)
        throw new Error("Oops! There may be an infinity loop");
    }
    return n;
  }
};
var b = class {
  constructor(e) {
    __publicField(this, "_nextNode", []);
    __publicField(this, "_end", false);
    this._nextNode = Array.from({ length: e }, () => null);
  }
};
function S(o = {}) {
  let e = /* @__PURE__ */ new Set([]);
  o.symbols && (Array.isArray(o.symbols) ? o.symbols.forEach(([p, s]) => {
    if (p.length === 0)
      throw new Error(`Cannot insert empty token! Token value: ${s}`);
    C.set(p, s);
  }) : Object.entries(o.symbols).forEach(([p, s]) => {
    if (p.length === 0)
      throw new Error(`Cannot insert empty token! Token value: ${s}`);
    C.set(p, s);
  }));
  for (let p of C.keys())
    [...p].forEach((s) => e.add(s));
  let t = Array.from(e);
  t.push(" ");
  let n = new N(t);
  for (let p of C.keys())
    n.insert(p);
  return n;
}
function J(o) {
  var _a;
  let e = { display: true, symbols: { dx: { type: "Const", tex: "{\\text{d}x}" }, dy: { type: "Const", tex: "{\\text{d}y}" }, dz: { type: "Const", tex: "{\\text{d}z}" }, dt: { type: "Const", tex: "{\\text{d}t}" }, "#": { type: "Const", tex: "\\displaystyle" }, atop: { type: "OperatorAOB", tex: "{ $1 \\atop $2 }" } }, replaceBeforeTokenizing: [[/&#(x?[0-9a-fA-F]+);/g, (t, n) => String.fromCodePoint(n[0] === "x" ? `0${n}` : n)]] };
  return typeof (o == null ? void 0 : o.display) < "u" && (e.display = o.display), (o == null ? void 0 : o.symbols) && (Array.isArray(o.symbols) ? o.symbols.forEach(([t, n]) => {
    e.symbols[t] = n;
  }) : e.symbols = { ...e.symbols, ...o.symbols }), ((_a = o == null ? void 0 : o.replaceBeforeTokenizing) == null ? void 0 : _a.length) && e.replaceBeforeTokenizing.push(...o.replaceBeforeTokenizing), e;
}
var _ = class {
  constructor(e) {
    __publicField(this, "trie");
    __publicField(this, "display");
    __publicField(this, "replaceLaws");
    let { display: t, symbols: n, replaceBeforeTokenizing: p } = J(e);
    this.trie = S({ symbols: n }), this.display = t, this.replaceLaws = p;
  }
  toTex(e, t) {
    try {
      e = this.replaceLaws.reduce((p, s) => p.replaceAll(s[0], s[1]), e);
      let n = h(P(this.trie.tryParsingAll(e)));
      return typeof (t == null ? void 0 : t.display) > "u" ? this.display && (n = `\\displaystyle{ ${n} }`) : t.display && (n = `\\displaystyle{ ${n} }`), n;
    } catch (n) {
      return `\\text{${String(n)}}`;
    }
  }
};

// src/utils.ts
function normalizeEscape(escape) {
  return escape.replace(/([$^\\.()[\]{}*?|])/g, "\\$1");
}
function isLatexCode(code) {
  const latexRegex = /\\([A-Za-z0-9]){2,}/gm;
  const texEmbedRegex = /tex".*"/;
  return latexRegex.test(code) && !texEmbedRegex.test(code);
}

// src/inline.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");
var AM = new _();
function selectionAndRangeOverlap(selection, rangeFrom, rangeTo) {
  for (const range of selection.ranges) {
    if (range.from <= rangeTo && range.to >= rangeFrom)
      return true;
  }
  return false;
}
function inlineRender(view, plugin) {
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile)
    return;
  const widgets = [];
  const selection = view.state.selection;
  const regex = /.*?_?inline-code_?.*/;
  for (const { from, to } of view.visibleRanges) {
    (0, import_language.syntaxTree)(view.state).iterate({
      from,
      to,
      enter: (node) => {
        const type = node.type;
        if (type.name.includes("formatting"))
          return;
        if (!regex.test(type.name))
          return;
        const start = node.from;
        const end = node.to;
        const { open, close } = plugin.settings.inline;
        if (selectionAndRangeOverlap(selection, start - open.length + 1, end + close.length - 1))
          return;
        const original = view.state.doc.sliceString(start - open.length + 1, end + close.length - 1).trim();
        const regex2 = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
        const matches = original.match(regex2);
        if (!matches)
          return;
        widgets.push(import_view.Decoration.replace({
          widget: new InlineWidget(matches[1], view),
          inclusive: false,
          block: false
        }).range(start - 1, end + 1));
      }
    });
  }
  return import_view.Decoration.set(widgets, true);
}
var InlineWidget = class extends import_view.WidgetType {
  constructor(rawQuery, view) {
    super();
    this.rawQuery = rawQuery;
    this.view = view;
  }
  eq(other) {
    if (other.rawQuery === this.rawQuery)
      return true;
    return false;
  }
  toDOM(_view) {
    const tex = AM.toTex(this.rawQuery);
    const mathEl = (0, import_obsidian.renderMath)(tex, false);
    (0, import_obsidian.finishRenderMath)();
    return mathEl;
  }
};
function inlinePlugin(plugin) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      var _a;
      this.decorations = (_a = inlineRender(view, plugin)) != null ? _a : import_view.Decoration.none;
    }
    update(update) {
      var _a;
      if (!update.state.field(import_obsidian.editorLivePreviewField)) {
        this.decorations = import_view.Decoration.none;
        return;
      }
      if (update.docChanged || update.viewportChanged || update.selectionSet)
        this.decorations = (_a = inlineRender(update.view, plugin)) != null ? _a : import_view.Decoration.none;
    }
  }, { decorations: (v2) => v2.decorations });
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var AsciiMathSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for asciimath" });
    new import_obsidian2.Setting(containerEl).setName("Code block prefix aliases").setDesc("Seperate different aliases with comma.").addText((text) => text.setPlaceholder("asciimath, am").setValue(this.plugin.settings.blockPrefix.join(", ")).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.blockPrefix = value.split(",").map((s) => s.trim()).filter(Boolean);
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Replace math blocks").setDesc("Enable this if you want to use AsciiMath but keep using default math blocks (dollar-sign blocks). This will not affect your previous notes that are written in LaTeX because the plugin will check which syntax to use before drawing the math.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.replaceMathBlock).onChange((v2) => {
        this.plugin.settings.replaceMathBlock = v2;
        this.plugin.setupMathBlockRendering();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Custom symbols").setDesc("Transforms custom symbols into LaTeX symbols. One row for each rule.").addTextArea((text) => {
      const el = text.setPlaceholder("symbol1, \\LaTeXSymbol1\nsymbol2, \\LaTeXSymbol2\n...").setValue(this.plugin.settings.customSymbols.map((r) => r.join(", ")).join("\n")).onChange((0, import_obsidian2.debounce)((value) => {
        this.plugin.settings.customSymbols = value.split("\n").map((r) => r.split(",").map((s) => s.trim()).filter(Boolean)).filter((l2) => l2.length);
      }, 1e3));
      el.inputEl.addClass("__asciimath_settings_custom-symbols");
    });
    new import_obsidian2.Setting(containerEl).setHeading().setName("Inline code math (deprecated)").setDesc("These settings will be removed in the next version of the plugin");
    new import_obsidian2.Setting(containerEl).setName("Disable deprecation warning").setDesc("Note: ignoring deprecation issues may make the plugin unusable with existing notes in the future.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableDeprecationWarning).onChange((v2) => {
        this.plugin.settings.disableDeprecationWarning = v2;
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath start").setDesc("The leading escape of the inline asciimath formula. It should starts with **only one backtick**.").addText((text) => text.setPlaceholder("`$").setValue(this.plugin.settings.inline.open).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.inline.open = value;
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath end").setDesc("The trailing escape of the inline asciimath formula. It should ends with **only one backtick**.").addText((text) => text.setPlaceholder("$`").setValue(this.plugin.settings.inline.close).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.inline.close = value;
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Don't forget to save and reload settings \u2192").addButton((btn) => btn.setButtonText("Save").onClick(async () => {
      const valid = validateSettings(this.plugin.settings);
      if (!valid.isValid) {
        new import_obsidian2.Notice(valid.message);
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      this.plugin.settings.blockPrefix.forEach((prefix) => {
        if (!this.plugin.existPrefixes.includes(prefix))
          this.plugin.registerAsciiMathCodeBlock(prefix);
      });
      this.plugin.AM = new _({
        symbols: this.plugin.calcSymbols()
      });
      new import_obsidian2.Notice("Asciimath settings reloaded successfully!");
    }));
  }
};
function validateSettings(settings) {
  if (settings.blockPrefix.length < 1) {
    return {
      isValid: false,
      message: "You should add at least 1 block prefix!"
    };
  }
  const { open, close } = settings.inline;
  if (!open.startsWith("`") || open.length <= 1 || open.startsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline leading escape!"
    };
  }
  if (!close.endsWith("`") || close.length <= 1 || close.endsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline trailing escape!"
    };
  }
  const { customSymbols } = settings;
  if (customSymbols.find((pair) => pair.length !== 2)) {
    return {
      isValid: false,
      message: "Custom rule should be two string split with a comma!"
    };
  }
  return {
    isValid: true,
    message: "OK"
  };
}

// src/confirm-modal.ts
var import_obsidian3 = require("obsidian");
var ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app2) {
    super(app2);
  }
  setMessage(message) {
    this.message = message;
    return this;
  }
  onConfirm(f2) {
    this.confirmHandler = f2;
    return this;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Are you sure?");
    new import_obsidian3.Setting(contentEl).setDesc(this.message);
    new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
      this.close();
      this.confirmHandler();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/symbol-search/modal.ts
var import_obsidian4 = require("obsidian");

// src/symbol-search/symbols.json
var symbols_default = [
  { am: "alpha", tex: "\\alpha" },
  { am: "beta", tex: "\\beta" },
  { am: "gamma", tex: "\\gamma" },
  { am: "Gamma", tex: "\\Gamma" },
  { am: "delta", tex: "\\delta" },
  { am: "Delta", tex: "\\Delta" },
  { am: "epsi", tex: "\\varepsilon" },
  { am: "epsilon", tex: "\\epsilon" },
  { am: "varepsilon", tex: "\\varepsilon" },
  { am: "zeta", tex: "\\zeta" },
  { am: "eta", tex: "\\eta" },
  { am: "theta", tex: "\\theta" },
  { am: "Theta", tex: "\\Theta" },
  { am: "vartheta", tex: "\\vartheta" },
  { am: "iota", tex: "\\iota" },
  { am: "kappa", tex: "\\kappa" },
  { am: "lambda", tex: "\\lambda" },
  { am: "Lambda", tex: "\\Lambda" },
  { am: "mu", tex: "\\mu" },
  { am: "nu", tex: "\\nu" },
  { am: "xi", tex: "\\xi" },
  { am: "Xi", tex: "\\Xi" },
  { am: "pi", tex: "\\pi" },
  { am: "Pi", tex: "\\Pi" },
  { am: "rho", tex: "\\rho" },
  { am: "sigma", tex: "\\sigma" },
  { am: "Sigma", tex: "\\Sigma" },
  { am: "tau", tex: "\\tau" },
  { am: "upsilon", tex: "\\upsilon" },
  { am: "phi", tex: "\\phi" },
  { am: "varphi", tex: "\\varphi" },
  { am: "varPhi", tex: "\\varPhi" },
  { am: "Phi", tex: "\\Phi" },
  { am: "chi", tex: "\\chi" },
  { am: "psi", tex: "\\psi" },
  { am: "Psi", tex: "\\Psi" },
  { am: "omega", tex: "\\omega" },
  { am: "Omega", tex: "\\Omega" },
  { am: "***", tex: "\\star" },
  { am: "star", tex: "\\star" },
  { am: "**", tex: "\\ast" },
  { am: "ast", tex: "\\ast" },
  { am: "*", tex: "\\cdot" },
  { am: "cdot", tex: "\\cdot" },
  { am: "//", tex: "{/}", rendered: "a//b" },
  { am: "\\\\", tex: "\\backslash" },
  { am: "setminus", tex: "\\setminus" },
  { am: "xx", tex: "\\times" },
  { am: "|><", tex: "\\ltimes" },
  { am: "><|", tex: "\\rtimes" },
  { am: "|><|", tex: "\\bowtie" },
  { am: "-:", tex: "\\div" },
  { am: "@", tex: "\\circ" },
  { am: "o+", tex: "\\oplus" },
  { am: "ox", tex: "\\otimes" },
  { am: "o.", tex: "\\odot" },
  { am: "sum", tex: "\\sum" },
  { am: "prod", tex: "\\prod" },
  { am: "^^", tex: "\\wedge" },
  { am: "^^^", tex: "\\bigwedge" },
  { am: "vv", tex: "\\vee" },
  { am: "vvv", tex: "\\bigvee" },
  { am: "nn", tex: "\\cap" },
  { am: "nnn", tex: "\\bigcap" },
  { am: "uu", tex: "\\cup" },
  { am: "uuu", tex: "\\bigcup" },
  { am: "!=", tex: "\\ne" },
  { am: "lt", tex: "<" },
  { am: "<=", tex: "\\leqslant" },
  { am: "le", tex: "\\le" },
  { am: "gt", tex: ">" },
  { am: ">=", tex: "\\geqslant" },
  { am: "ge", tex: "\\ge" },
  { am: "-<", tex: "\\prec" },
  { am: ">-", tex: "\\succ" },
  { am: "-<=", tex: "\\preceq" },
  { am: ">-=", tex: "\\succeq" },
  { am: "in", tex: "\\in" },
  { am: "!in", tex: "\\notin" },
  { am: "sub", tex: "\\subset" },
  { am: "sup", tex: "\\supset" },
  { am: "sube", tex: "\\subseteq" },
  { am: "supe", tex: "\\supseteq" },
  { am: "-=", tex: "\\equiv" },
  { am: "~=", tex: "\\cong" },
  { am: "~", tex: "\\sim" },
  { am: "~~", tex: "\\approx" },
  { am: "\\#", tex: "\\#" },
  { am: "\\&", tex: "\\&" },
  { am: "\\@", tex: "@" },
  { am: "\\%", tex: "\\%" },
  { am: "%", tex: "\\%" },
  { am: "\\$", tex: "\\$" },
  { am: "\\,", tex: "\\," },
  { am: "\\;", tex: "\\;" },
  { am: "\\:", tex: "\\:" },
  { am: "\\!", tex: "\\!" },
  { am: "enspace", tex: "a\\enspace b" },
  { am: "hspace", tex: "\\hspace{$1}", rendered: "a\\hspace{12pt}b", placeholder: "($1)", fill: ["12pt"] },
  { am: "prop", tex: "\\propto" },
  { am: "comp", tex: "\\complement" },
  { am: "complement", tex: "\\complement" },
  { am: "if", tex: "\\text{if}\\quad", rendered: "\\text{if}" },
  { am: "otherwise", tex: "\\text{otherwise}\\quad", rendered: "\\text{otherwise}" },
  { am: "and", tex: " and ", rendered: "\\text{ and }" },
  { am: "or", tex: " or ", rendered: "\\text{ or }" },
  { am: "not", tex: "\\neg" },
  { am: "=>", tex: "\\implies" },
  { am: "~>", tex: "\\rightsquigarrow" },
  { am: "-/->", tex: "\\nrightarrow" },
  { am: "<-/-", tex: "\\nleftarrow" },
  { am: "<-/->", tex: "\\nleftrightarrow" },
  { am: "<=>", tex: "\\iff" },
  { am: "iff", tex: "\\iff" },
  { am: "AA", tex: "\\forall" },
  { am: "EE", tex: "\\exists" },
  { am: "_|_", tex: "\\bot" },
  { am: "TT", tex: "\\top" },
  { am: "|--", tex: "\\vdash" },
  { am: "|==", tex: "\\models" },
  { am: "int", tex: "\\int" },
  { am: "oint", tex: "\\oint" },
  { am: "del", tex: "\\partial" },
  { am: "grad", tex: "\\nabla" },
  { am: "+-", tex: "\\pm" },
  { am: "-+", tex: "\\mp" },
  { am: "O/", tex: "\\varnothing" },
  { am: "oo", tex: "\\infty" },
  { am: "aleph", tex: "\\aleph" },
  { am: "...", tex: "\\ldots" },
  { am: ":.", tex: "\\therefore" },
  { am: ":'", tex: "\\because" },
  { am: "/_", tex: "\\angle" },
  { am: "/_\\", tex: "\\triangle" },
  { am: "quad", tex: "\\quad" },
  { am: "qquad", tex: "\\qquad" },
  { am: "cdots", tex: "\\cdots" },
  { am: "vdots", tex: "\\vdots" },
  { am: "ddots", tex: "\\ddots" },
  { am: "diamond", tex: "\\diamond" },
  { am: "Lap", tex: "\\mathscr{L}" },
  { am: "square", tex: "\\square" },
  { am: "|__", tex: "\\lfloor" },
  { am: "__|", tex: "\\rfloor" },
  { am: "|~", tex: "\\lceil" },
  { am: "~|", tex: "\\rceil" },
  { am: "CC", tex: "\\mathbb{C}" },
  { am: "NN", tex: "\\mathbb{N}" },
  { am: "QQ", tex: "\\mathbb{Q}" },
  { am: "RR", tex: "\\mathbb{R}" },
  { am: "ZZ", tex: "\\mathbb{Z}" },
  { am: "'", tex: "^{\\prime}" },
  { am: "''", tex: "^{\\prime\\prime}" },
  { am: "'''", tex: "^{\\prime\\prime\\prime}" },
  { am: "lim", tex: "\\lim_{$2} $1", placeholder: "_($2) $1", fill: ["f(x)", "x\\to 0"] },
  { am: "sin", tex: "\\sin" },
  { am: "cos", tex: "\\cos" },
  { am: "tan", tex: "\\tan" },
  { am: "sinh", tex: "\\sinh" },
  { am: "cosh", tex: "\\cosh" },
  { am: "tanh", tex: "\\tanh" },
  { am: "cot", tex: "\\cot" },
  { am: "sec", tex: "\\sec" },
  { am: "csc", tex: "\\csc" },
  { am: "arcsin", tex: "\\arcsin" },
  { am: "arccos", tex: "\\arccos" },
  { am: "arctan", tex: "\\arctan" },
  { am: "coth", tex: "\\coth" },
  { am: "sech", tex: "\\operatorname{sech}" },
  { am: "csch", tex: "\\operatorname{csch}" },
  { am: "exp", tex: "\\exp" },
  { am: "log", tex: "\\log" },
  { am: "ln", tex: "\\ln" },
  { am: "det", tex: "\\det" },
  { am: "dim", tex: "\\dim" },
  { am: "gcd", tex: "\\gcd" },
  { am: "lcm", tex: "\\operatorname{lcm}" },
  { am: "min", tex: "\\min" },
  { am: "max", tex: "\\max" },
  { am: "Sup", tex: "\\sup" },
  { am: "inf", tex: "\\inf" },
  { am: "mod", tex: "\\operatorname{mod}" },
  { am: "sgn", tex: "\\operatorname{sgn}" },
  { am: "abs", tex: "\\left| $1 \\right|", placeholder: "($1)", fill: ["a"] },
  { am: "norm", tex: "\\left\\| $1 \\right\\|", placeholder: "($1)", fill: ["a"] },
  { am: "floor", tex: "\\left\\lfloor $1 \\right\\rfloor", placeholder: "($1)", fill: ["a"] },
  { am: "ceil", tex: "\\left\\lceil $1 \\right\\rceil", placeholder: "($1)", fill: ["a"] },
  { am: "uarr", tex: "\\uparrow" },
  { am: "uparrow", tex: "\\uparrow" },
  { am: "darr", tex: "\\downarrow" },
  { am: "downarrow", tex: "\\downarrow" },
  { am: "rarr", tex: "\\rightarrow" },
  { am: "rightarrow", tex: "\\rightarrow" },
  { am: "to", tex: "\\to" },
  { am: "->", tex: "\\to" },
  { am: "<-", tex: "\\gets" },
  { am: ">->", tex: "\\rightarrowtail" },
  { am: "->>", tex: "\\twoheadrightarrow" },
  { am: ">->>", tex: "\u2916" },
  { am: "|->", tex: "\\mapsto" },
  { am: "larr", tex: "\\leftarrow" },
  { am: "leftarrow", tex: "\\leftarrow" },
  { am: "harr", tex: "\\leftrightarrow" },
  { am: "rArr", tex: "\\Rightarrow" },
  { am: "lArr", tex: "\\Leftarrow" },
  { am: "hArr", tex: "\\Leftrightarrow" },
  { am: "curvArrLt", tex: "\\curvearrowleft" },
  { am: "curvArrRt", tex: "\\curvearrowright" },
  { am: "circArrLt", tex: "\\circlearrowleft" },
  { am: "circArrRt", tex: "\\circlearrowright" },
  { am: "sqrt", tex: "\\sqrt{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "root", tex: "\\sqrt[ $1 ]{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "frac", tex: "\\frac{ $1 }{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "/", tex: "\\frac{ $1 }{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "choose", tex: "{ a \\choose b }" },
  { am: "_", tex: "_{ $1 }", rendered: "x_{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "^", tex: "^{ $1 }", rendered: "x^{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "stackrel", tex: "\\stackrel{ $1 }{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "overset", tex: "\\overset{ $1 }{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "underset", tex: "\\underset{ $1 }{ $2 }", placeholder: "($1)($2)", fill: ["a", "b"] },
  { am: "hat", tex: "\\hat{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "Hat", tex: "\\widehat{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "ol", tex: "\\overline{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "overline", tex: "\\overline{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "arc", tex: "\\stackrel{\\frown}{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "bar", tex: "\\bar{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "vec", tex: "\\vec{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "Vec", tex: "\\overrightarrow{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "tilde", tex: "\\tilde{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "Tilde", tex: "\\widetilde{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "dot", tex: "\\dot{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "ddot", tex: "\\ddot{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "ul", tex: "\\underline{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "underline", tex: "\\underline{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "underbrace", tex: "\\underbrace{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "ubrace", tex: "\\underbrace{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "overbrace", tex: "\\overbrace{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "obrace", tex: "\\overbrace{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "color", tex: "{ \\color{$2} $1 }", placeholder: "($2)($1)", fill: ["b", "red"] },
  { am: "phantom", tex: "\\phantom{a}", placeholder: "($1)", fill: ["a"] },
  { am: "text", tex: "\\text{$1}", rendered: "", placeholder: '"$1"', fill: ["a"] },
  { am: "tex", tex: "$1", placeholder: '"$1"', fill: ["a"] },
  { am: "mbox", tex: "\\mbox{a}", placeholder: "($1)", fill: ["a"] },
  { am: "op", tex: "\\operatorname{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "cancel", tex: "\\cancel{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "bb", tex: "\\mathbf{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "sf", tex: "\\mathsf{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "bbb", tex: "\\mathbb{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "cc", tex: "\\mathcal{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "tt", tex: "\\mathtt{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "fr", tex: "\\mathfrak{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "bm", tex: "\\boldsymbol{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "rm", tex: "\\mathrm{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "scr", tex: "\\mathscr{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "limits", tex: "\\mathop{ $1 }\\limits", rendered: "\\mathop{ $1 }\\limits_{k=1}^n", placeholder: "($1)_($2)^($3)", fill: ["a", "k=1", "n"] },
  { am: "iint", tex: "\\iint" },
  { am: "iiint", tex: "\\iiint" },
  { am: "oiint", tex: "\u222F" },
  { am: "oiiint", tex: "\u2230" },
  { am: "laplace", tex: "\\Delta" },
  { am: "==", tex: "\\xlongequal[ $2 ]{ $1 }", placeholder: "^($1)_($2)", fill: ["a", "b"] },
  { am: "-->", tex: "\\xrightarrow[ $2 ]{ $1 }", placeholder: "^($1)_($2)", fill: ["a", "b"] },
  { am: "||", tex: "\\Vert", rendered: "\\Vert" },
  { am: "!||", tex: "\u2226" },
  { am: "S=", tex: "\u224C" },
  { am: "S~", tex: "\u223D" },
  { am: "!-=", tex: "\\not\\equiv" },
  { am: "!|", tex: "\u2224" },
  { am: "!", tex: "{a !}" },
  { am: "!!", tex: "{a !!}" },
  { am: "!sube", tex: "\\not\\subseteq" },
  { am: "!supe", tex: "\\not\\supseteq" },
  { am: "subne", tex: "\\subsetneqq" },
  { am: "supne", tex: "\\supsetneqq" },
  { am: "lhd", tex: "\\lhd" },
  { am: "rhd", tex: "\\rhd" },
  { am: "normal", tex: "\\unlhd" },
  { am: "rnormal", tex: "\\unrhd" },
  { am: "(", tex: "(" },
  { am: ")", tex: ")" },
  { am: "[", tex: "[" },
  { am: "]", tex: "]" },
  { am: "{", tex: "\\lbrace" },
  { am: "}", tex: "\\rbrace" },
  { am: "(:", tex: "\\langle" },
  { am: ":)", tex: "\\rangle" },
  { am: "{:", tex: "{", rendered: "" },
  { am: ":}", tex: "}", rendered: "" },
  { am: "|", tex: "|" },
  { am: "&", tex: "&" },
  { am: "&&", tex: "&&" },
  { am: ",", tex: "," },
  { am: ";", tex: ";" },
  { am: "pp", tex: "\\frac{ \\partial ^ $3 { $1 } }{ \\partial $2 ^ $3 }", placeholder: "^$3 ($1)($2)", fill: ["f", "x", "n"] },
  { am: "dd", tex: "\\frac{ \\mathrm{d} ^ $3 { $1 } }{ \\mathrm{d} $2 ^ $3 }", placeholder: "^$3 ($1)($2)", fill: ["f", "x", "n"] },
  { am: "tiny", tex: "{\\tiny $1 }", placeholder: "($1)", fill: ["\\text{text}"] },
  { am: "small", tex: "{\\small $1 }", placeholder: "($1)", fill: ["\\text{text}"] },
  { am: "large", tex: "{\\large $1 }", placeholder: "($1)", fill: ["\\text{text}"] },
  { am: "huge", tex: "{\\huge $1 }", placeholder: "($1)", fill: ["\\text{text}"] }
];

// src/symbol-search/modal.ts
var SymbolSearchModal = class extends import_obsidian4.SuggestModal {
  constructor(app2, sel, am) {
    super(app2);
    this.sel = sel;
    this.am = am;
    this.renderCount = 0;
    this.renderMax = 0;
  }
  getSuggestions(query) {
    query = query.toLowerCase();
    const suggestions = symbols_default.filter((sym) => [sym.am, sym.tex].some((v2) => v2.toLocaleLowerCase().includes(query)));
    this.renderCount = 0;
    this.renderMax = Math.min(suggestions.length, 100);
    return suggestions;
  }
  renderSuggestion(sym, el) {
    this.renderCount++;
    let { am, tex, rendered } = sym;
    el.classList.add("__asciimath-symbol-search-result");
    const text = el.createDiv();
    const amLine = text.createDiv();
    amLine.createSpan({ text: am });
    let toBeRendered = typeof rendered !== "undefined" ? rendered : tex;
    if ("placeholder" in sym) {
      const { placeholder, fill } = sym;
      let template = placeholder;
      if (this.sel) {
        const selToTex = am === "tex" || am === "text" ? this.sel : this.am.toTex(this.sel, { display: false });
        template = template.replace("$1", this.sel);
        tex = tex.replace("$1", selToTex);
        toBeRendered = toBeRendered.replace("$1", selToTex);
      }
      fill.forEach((x, i2) => {
        template = template.replace(`$${i2 + 1}`, x);
        toBeRendered = toBeRendered.replaceAll(`$${i2 + 1}`, x);
        tex = tex.replaceAll(`$${i2 + 1}`, x);
      });
      amLine.createSpan({ text: ` ${template}`, cls: "__asciimath-symbol-search-placeholder" });
    }
    text.createEl("small", { text: `LaTeX alternative: ${tex}` });
    el.createDiv("__asciimath-symbol-search-preview math", (el2) => {
      if (am === "tex")
        toBeRendered = `tex"${toBeRendered}"`;
      el2.innerHTML = `
        <mjx-container class="MathJax" jax="CHTML">
        ${(0, import_obsidian4.renderMath)(toBeRendered, true).innerHTML}
        </mjx-container>
      `;
      if (this.renderCount >= this.renderMax)
        (0, import_obsidian4.finishRenderMath)();
    });
  }
  onSelected(cb) {
    this.callback = cb;
  }
  onChooseSuggestion(sym) {
    this.callback(sym);
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  blockPrefix: ["asciimath", "am"],
  disableDeprecationWarning: false,
  replaceMathBlock: true,
  inline: {
    open: "`$",
    close: "$`"
  },
  customSymbols: []
};
function toTex(am, content) {
  const tex = am.toTex(content);
  return tex.replace(/(\{|\})(\1+)/g, (...args) => Array(args[2].length + 1).fill(args[1]).join(" "));
}
var AsciiMathPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.existPrefixes = [];
    this.postProcessors = /* @__PURE__ */ new Map();
  }
  calcSymbols() {
    return this.settings.customSymbols.map(([k2, v2]) => {
      return [k2, { type: f.Const, tex: v2 }];
    });
  }
  onunload() {
    console.log("Obsidian asciimath unloaded");
    MathJax.tex2chtml = this.tex2chtml;
    this.unregister();
  }
  unregister() {
    this.postProcessors.forEach((value) => {
      import_obsidian5.MarkdownPreviewRenderer.unregisterPostProcessor(value);
    });
    this.postProcessors.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  setupMathBlockRendering() {
    this.tex2chtml = MathJax.tex2chtml;
    if (this.settings.replaceMathBlock)
      MathJax.tex2chtml = (s, r) => this.convertMathCode(s, r);
    else
      MathJax.tex2chtml = this.tex2chtml;
  }
  convertMathCode(source, r) {
    if (this.settings.replaceMathBlock && !isLatexCode(source))
      source = this.AM.toTex(source);
    return this.tex2chtml(source, r);
  }
  registerAsciiMathCodeBlock(prefix) {
    this.postProcessors.set(prefix, this.registerMarkdownCodeBlockProcessor(prefix, (src, el, ctx) => this.postProcessor(prefix, src, el, ctx)));
  }
  postProcessor(_prefix, src, el, _2) {
    const mathEl = (0, import_obsidian5.renderMath)(src, true);
    el.appendChild(mathEl);
    (0, import_obsidian5.finishRenderMath)();
  }
  async onload() {
    await this.loadSettings();
    await (0, import_obsidian5.loadMathJax)();
    this.AM = new _({
      symbols: this.calcSymbols()
    });
    if (!MathJax) {
      console.warn("MathJax was not defined despite loading it.");
      new import_obsidian5.Notice("Error: MathJax was not defined despite loading it!");
      return;
    }
    this.app.workspace.on("file-open", async (file) => {
      if (!file || this.settings.disableDeprecationWarning)
        return;
      const content = await this.app.vault.read(file);
      const [open, close] = Object.values(this.settings.inline).map(normalizeEscape);
      const inlineReg = new RegExp(`${open}(.*?)${close}`, "g");
      if (inlineReg.test(content)) {
        new import_obsidian5.Notice(esm_default`
          Obsidian AsciiMath:

          Inline math with single backticks is deprecated. Refer to the plugin description to fix this issue.
          You also can disable this warning in the plugin settings.

          Click here to dismiss this message.
        `, 0);
      }
    });
    this.addCommand({
      id: "insert-asciimath-block",
      name: "Insert asciimath block",
      editorCallback: (editor, _view) => {
        editor.replaceSelection(`\`\`\`${this.settings.blockPrefix[0] || "asciimath"}
${editor.getDoc().getSelection()}
\`\`\``);
        const cursor = editor.getCursor();
        editor.setCursor(cursor.line - 1);
      }
    });
    this.addCommand({
      id: "insert-asciimath-inline",
      name: "Insert asciimath inline (deprecated)",
      callback: () => {
        const modal = new import_obsidian5.Modal(this.app);
        modal.titleEl.setText("This command is deprecated");
        new import_obsidian5.Setting(modal.contentEl).setName('It is advised to convert your old AsciiMath blocks to new syntax using "Update old AsciiMath" commands and proceed using default obsidian dollar-sign blocks with AsciiMath syntax');
        modal.open();
      }
    });
    this.addCommand({
      id: "convert-am-block-into-mathjax-in-current-file",
      name: "Convert AsciiMath to LaTeX (active file)",
      callback: this.actionConvertActiveFile("Tex" /* Tex */, "This will replace all AsciiMath blocks with LaTeX math blocks in the active file. THIS ACTION CANNOT BE UNDONE.")
    });
    this.addCommand({
      id: "convert-am-inline-into-new-syntax-in-current-file",
      name: "Update old AsciiMath (active file)",
      callback: this.actionConvertActiveFile("Asciimath" /* Asciimath */, esm_default`
        This will replace all Asciimath formulas of old syntax (like \`\$ and \$\`) with new syntax (wrapped with dollar signs),
        which is more convenient to use.
        THIS ACTION CANNOT BE UNDONE.`)
    });
    this.addCommand({
      id: "convert-am-block-into-mathjax-in-vault",
      name: "Convert AsciiMath to LaTeX (entire vault)",
      callback: this.actionConvertEntireVault("Tex" /* Tex */, "This will replace all AsciiMath formulas with LaTeX math blocks in the entire vault. THIS ACTION CANNOT BE UNDONE.")
    });
    this.addCommand({
      id: "convert-am-inline-into-new-syntax-in-vault",
      name: "Update old AsciiMath (entire vault)",
      callback: this.actionConvertEntireVault("Asciimath" /* Asciimath */, esm_default`
        This will replace all Asciimath formulas of old syntax (like \`\$ and \$\`) with new syntax (wrapped with dollar signs),
        which is more convenient to use.
        THIS ACTION CANNOT BE UNDONE.`)
    });
    this.addCommand({
      id: "asciimath-insert-symbol",
      icon: "sigma",
      name: "Insert AsciiMath symbol",
      editorCallback: this.modalCallback()
    });
    this.postProcessors = /* @__PURE__ */ new Map();
    this.app.workspace.onLayoutReady(async () => {
      this.settings.blockPrefix.forEach((prefix) => {
        this.registerAsciiMathCodeBlock(prefix);
        this.existPrefixes.push(prefix);
      });
    });
    this.registerEditorExtension([inlinePlugin(this)]);
    this.registerMarkdownPostProcessor(this.postProcessorInline.bind(this));
    this.setupMathBlockRendering();
    this.addSettingTab(new AsciiMathSettingTab(this.app, this));
    console.log("Obsidian asciimath loaded");
  }
  modalCallback() {
    return (editor) => {
      const sel = editor.getSelection();
      const modal = new SymbolSearchModal(this.app, sel, this.AM);
      modal.setPlaceholder("Start typing AsciiMath or LaTeX symbol name");
      modal.onSelected((sym) => {
        var _a;
        const { am } = sym;
        if ("placeholder" in sym) {
          const { placeholder, fill } = sym;
          let tempExceptFirst = placeholder;
          for (let i2 = 2; i2 <= fill.length; i2++)
            tempExceptFirst = tempExceptFirst.replace(`$${i2}`, "");
          const temp = tempExceptFirst.replace("$1", "");
          if (!sel) {
            const cur = editor.getCursor();
            const placeholder_a_pos = placeholder.indexOf("$1");
            const spacesBefore$1 = ((_a = placeholder.substring(0, placeholder_a_pos).match(/(\$\d+?)/g)) == null ? void 0 : _a.join("").length) || 0;
            editor.replaceSelection(am + temp);
            editor.setCursor({ line: cur.line, ch: cur.ch + am.length + placeholder_a_pos - spacesBefore$1 });
          } else {
            const placeholder_b_pos = placeholder.indexOf("$2");
            const cur = editor.getCursor("to");
            editor.replaceSelection(am + tempExceptFirst.replace("$1", sel));
            if (placeholder_b_pos !== -1) {
              const $before$2 = placeholder.substring(0, placeholder_b_pos).match(/(\$\d+?)/g);
              const $spacesBefore$2 = ($before$2 == null ? void 0 : $before$2.join("").length) || 0;
              const $2before$1 = !$before$2 || !$before$2.includes("$1") ? sel.length : 0;
              editor.setCursor({ line: cur.line, ch: cur.ch + am.length + placeholder_b_pos - $spacesBefore$2 - $2before$1 });
            } else {
              editor.setCursor({ line: cur.line, ch: cur.ch + am.length + placeholder.length - 2 });
            }
          }
        } else {
          editor.replaceSelection(am);
        }
      });
      modal.open();
    };
  }
  actionConvertActiveFile(target, message) {
    return async () => new ConfirmModal(this.app).setMessage(message).onConfirm(async () => {
      const file = this.app.workspace.getActiveFile();
      const { block, inline } = await this.convertAsciiMathInFile(file, target);
      new import_obsidian5.Notice(`Converted ${block} blocks and ${inline} inline formulas.`);
    }).open();
  }
  actionConvertEntireVault(target, message) {
    return async () => new ConfirmModal(this.app).setMessage(message).onConfirm(async () => {
      const allConvertionRes = await Promise.all(this.app.vault.getMarkdownFiles().map(async (f2) => {
        const convertionRes = await this.convertAsciiMathInFile(f2, target);
        return { ...convertionRes, hasAsciimath: convertionRes.block || convertionRes.inline };
      }));
      const { block, inline, fileNum } = allConvertionRes.reduce((x, y) => {
        return { block: x.block + y.block, inline: x.inline + y.inline, fileNum: x.fileNum + y.hasAsciimath };
      }, { block: 0, inline: 0, fileNum: 0 });
      new import_obsidian5.Notice(`Converted ${block} blocks and ${inline} inline formulas in ${fileNum} file${fileNum > 1 ? "s" : ""}.`);
    }).open();
  }
  async convertAsciiMathInFile(file, target) {
    const convertionRes = { block: 0, inline: 0 };
    let content = await this.app.vault.read(file);
    const blockReg = new RegExp(`((\`|~){3,})(${this.settings.blockPrefix.join("|")})([\\s\\S]*?)\\n\\1`, "gm");
    const [open, close] = Object.values(this.settings.inline).map(normalizeEscape);
    const inlineReg = new RegExp(`${open}(.*?)${close}`, "g");
    try {
      const blockIterator = content.matchAll(blockReg);
      let match;
      while (!(match = blockIterator.next()).done) {
        const block = match.value[0];
        const blockContent = match.value[4];
        const innerContent = target === "Tex" /* Tex */ ? toTex(this.AM, blockContent) : blockContent.trim();
        content = content.replace(block, `$$$$
${innerContent}
$$$$`);
        convertionRes.block++;
      }
      const inlineBlockIterator = content.matchAll(inlineReg);
      while (!(match = inlineBlockIterator.next()).done) {
        const block = match.value[0];
        const blockContent = match.value[1];
        const innerContent = target === "Tex" /* Tex */ ? toTex(this.AM, blockContent) : blockContent;
        content = content.replace(block, `$$${innerContent.trim()}$$`);
        convertionRes.inline++;
      }
      await this.app.vault.modify(file, content);
    } catch (e) {
      new import_obsidian5.Notice(String(e));
    }
    return convertionRes;
  }
  async postProcessorInline(el, _ctx) {
    const nodeList = el.querySelectorAll("code");
    if (!nodeList.length)
      return;
    for (let i2 = 0; i2 < nodeList.length; i2++) {
      const node = nodeList.item(i2);
      if (node.className.trim())
        continue;
      let { open, close } = this.settings.inline;
      open = open.slice(1);
      close = close.substring(0, close.length - 1);
      const regex = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
      const matches = node.innerText.match(regex);
      if (!matches)
        continue;
      const mathEl = (0, import_obsidian5.renderMath)(matches[1], false);
      (0, import_obsidian5.finishRenderMath)();
      node.replaceWith(mathEl);
    }
  }
};
